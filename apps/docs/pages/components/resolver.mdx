---
title: "Resolver"
weight: 2
---

# Custom Resolver

The enhanced ENS resolver that provides organizational-specific resolution logic, multi-chain support, and governance-aware metadata management.

## Overview

The Custom Resolver extends the standard ENS resolver with:
- **Governance Integration**: Updates controlled by DAO voting
- **Multi-chain Resolution**: Addresses for multiple blockchain networks
- **CCIP-Read Support**: Off-chain data integration with on-chain verification
- **Wildcard Resolution**: Subdomain delegation to working groups
- **Rich Metadata**: Extended text records for organizational data

## ENSIP Compliance

| ENSIP | Feature | Status |
|-------|---------|---------|
| ENSIP-1 | Address Resolution | ✅ Implemented |
| ENSIP-3 | Reverse Resolution | ✅ Implemented |
| ENSIP-5 | Text Records | ✅ Implemented |
| ENSIP-9 | Multi-chain Addresses | ✅ Implemented |
| ENSIP-10 | Wildcard Resolution | ✅ Implemented |
| ENSIP-11 | EVM Chain Address | ✅ Implemented |
| ENSIP-12 | Avatar Records | ✅ Implemented |
| ENSIP-16 | Off-chain Resolution | ✅ Implemented |

## Contract Interface

```solidity
interface IOrgResolver {
    // ENSIP-1: Basic resolution
    function addr(bytes32 node) external view returns (address);
    function addr(bytes32 node, uint coinType) external view returns (bytes memory);
    
    // ENSIP-5: Text records
    function text(bytes32 node, string calldata key) external view returns (string memory);
    function setText(bytes32 node, string calldata key, string calldata value) external;
    
    // ENSIP-10: Wildcard resolution
    function resolve(bytes memory name, bytes memory data) 
        external view returns (bytes memory result);
    
    // ENSIP-16: Off-chain resolution (CCIP-Read)
    function resolveWithProof(bytes memory name, bytes memory data)
        external view returns (bytes memory result);
    
    // Governance functions
    function updateTextRecords(
        bytes32 node,
        string[] calldata keys, 
        string[] calldata values
    ) external;
    
    function delegateSubdomain(
        bytes32 parent,
        string calldata label,
        address manager
    ) external;
}
```

## Standard Text Records

### Core Organizational Fields
```typescript
interface OrgTextRecords {
  // Basic information
  'alias': string;           // Display name
  'description': string;     // Organization description
  'avatar': string;          // ENSIP-12 avatar
  'email': string;           // Contact email
  'url': string;             // Primary website
  
  // Social media (ENSIP-5 standard)
  'com.twitter': string;     // Twitter handle
  'com.github': string;      // GitHub organization
  'com.discord': string;     // Discord server
  'org.telegram': string;    // Telegram group
  
  // Governance specific
  'governance.contract': string;     // Voting contract address
  'governance.proposal-threshold': string; // Min tokens to propose
  'governance.voting-delay': string;       // Voting delay period
  'governance.type': string;               // DAO framework type
}
```

### Extended Metadata
```typescript
interface ExtendedTextRecords {
  // Legal and compliance
  'legal.name': string;         // Legal entity name
  'legal.jurisdiction': string; // Legal jurisdiction
  'legal.registration': string; // Registration number
  
  // Financial
  'treasury.address': string;   // Treasury contract
  'treasury.tokens': string;    // Managed token list
  'treasury.value': string;     // Total value (USD)
  
  // Technical
  'tech.docs': string;          // Documentation URL
  'tech.github': string;        // Code repository
  'tech.security': string;      // Security contact
}
```

## Multi-chain Address Resolution

### Supported Networks
```solidity
// Standard coin types (SLIP-44)
uint256 constant ETHEREUM = 60;
uint256 constant BITCOIN = 0;
uint256 constant POLYGON = 137;

// EVM chain IDs (ENSIP-11)
uint256 constant ARBITRUM = 42161;
uint256 constant OPTIMISM = 10;
uint256 constant BASE = 8453;
```

### Address Setting
```solidity
function setAddr(bytes32 node, uint coinType, bytes calldata addr) 
    external 
    onlyAuthorized(node) 
{
    _addresses[node][coinType] = addr;
    emit AddressChanged(node, coinType, addr);
}

function setMultiAddr(
    bytes32 node,
    uint256[] calldata coinTypes,
    bytes[] calldata addresses
) external onlyAuthorized(node) {
    require(coinTypes.length == addresses.length, "Length mismatch");
    
    for (uint i = 0; i < coinTypes.length; i++) {
        _addresses[node][coinTypes[i]] = addresses[i];
        emit AddressChanged(node, coinTypes[i], addresses[i]);
    }
}
```

## Wildcard Resolution

### Subdomain Pattern Matching
```solidity
function resolve(bytes memory name, bytes memory data) 
    external view returns (bytes memory) 
{
    // Parse DNS-encoded name
    (bytes32 parentNode, string memory label) = parseName(name);
    
    // Check if parent has wildcard delegation
    address subdomainManager = _subdomainManagers[parentNode][label];
    if (subdomainManager != address(0)) {
        // Delegate to subdomain manager
        return ISubdomainManager(subdomainManager).resolve(name, data);
    }
    
    // Fall back to parent resolution
    return _resolveStandard(parentNode, data);
}
```

### Subdomain Delegation
```solidity
function delegateSubdomain(
    bytes32 parent,
    string calldata label,
    address manager
) external onlyAuthorized(parent) {
    bytes32 labelHash = keccak256(bytes(label));
    _subdomainManagers[parent][labelHash] = manager;
    
    emit SubdomainDelegated(parent, labelHash, manager);
}
```

## CCIP-Read Integration

### Off-chain Gateway Support
```solidity
error OffchainLookup(
    address sender,
    string[] urls,
    bytes callData,
    bytes4 callbackFunction,
    bytes extraData
);

function text(bytes32 node, string calldata key) 
    external view returns (string memory) 
{
    // Check if off-chain resolution is enabled
    if (_isOffchainEnabled[node]) {
        string[] memory urls = new string[](1);
        urls[0] = _gatewayUrls[node];
        
        revert OffchainLookup(
            address(this),
            urls,
            abi.encodeWithSelector(this.text.selector, node, key),
            this.textWithProof.selector,
            abi.encode(node, key)
        );
    }
    
    // Return on-chain data
    return _texts[node][key];
}
```

### Signature Verification
```solidity
function textWithProof(
    bytes calldata response,
    bytes calldata extraData
) external view returns (string memory) {
    (bytes32 node, string memory key) = abi.decode(extraData, (bytes32, string));
    (string memory value, bytes memory signature) = abi.decode(response, (string, bytes));
    
    // Verify signature from authorized gateway
    bytes32 hash = keccak256(abi.encodePacked(node, key, value, block.timestamp));
    address signer = ECDSA.recover(hash, signature);
    require(_gatewaySigners[node] == signer, "Invalid signature");
    
    return value;
}
```

## Governance Integration

### Access Control
```solidity
modifier onlyAuthorized(bytes32 node) {
    require(
        _isAuthorized(node, msg.sender) || 
        _hasGovernanceApproval(node, msg.data),
        "Not authorized"
    );
    _;
}

function _hasGovernanceApproval(bytes32 node, bytes memory data) 
    internal view returns (bool) 
{
    address governance = _governanceContracts[node];
    if (governance == address(0)) return false;
    
    return IGovernance(governance).isApproved(data);
}
```

### Batch Updates
```solidity
function batchUpdateRecords(
    bytes32 node,
    string[] calldata keys,
    string[] calldata values,
    uint256[] calldata coinTypes,
    bytes[] calldata addresses
) external onlyAuthorized(node) {
    // Update text records
    for (uint i = 0; i < keys.length; i++) {
        _texts[node][keys[i]] = values[i];
        emit TextChanged(node, keys[i], values[i]);
    }
    
    // Update addresses
    for (uint i = 0; i < coinTypes.length; i++) {
        _addresses[node][coinTypes[i]] = addresses[i];
        emit AddressChanged(node, coinTypes[i], addresses[i]);
    }
}
```

## Avatar Support (ENSIP-12)

### Avatar Resolution
```solidity
function avatar(bytes32 node) external view returns (string memory) {
    string memory avatarText = text(node, "avatar");
    
    // Handle different avatar types
    if (bytes(avatarText).length == 0) return "";
    
    // NFT format: eip155:1/erc721:0x123.../456
    if (_isNFTAvatar(avatarText)) {
        return _resolveNFTAvatar(avatarText);
    }
    
    // IPFS format: ipfs://QmHash...
    if (_isIPFSAvatar(avatarText)) {
        return _resolveIPFSAvatar(avatarText);
    }
    
    // HTTP URL
    return avatarText;
}
```

## Performance Optimizations

### Gas Efficiency
```solidity
// Packed storage for frequently accessed data
struct PackedOrgData {
    address governance;     // 20 bytes
    uint96 lastUpdate;      // 12 bytes (timestamp)
}

mapping(bytes32 => PackedOrgData) private _packedData;
```

### Batch Operations
```solidity
function multicall(bytes[] calldata data) external returns (bytes[] memory results) {
    results = new bytes[](data.length);
    for (uint256 i = 0; i < data.length; i++) {
        (bool success, bytes memory result) = address(this).delegatecall(data[i]);
        require(success, "Multicall failed");
        results[i] = result;
    }
}
```

## Events

```solidity
event TextChanged(bytes32 indexed node, string indexed key, string value);
event AddressChanged(bytes32 indexed node, uint256 coinType, bytes newAddress);
event SubdomainDelegated(bytes32 indexed parent, bytes32 indexed label, address manager);
event OffchainGatewaySet(bytes32 indexed node, string url, address signer);
event GovernanceConfigured(bytes32 indexed node, address governance);
```

## Security Features

### Reentrancy Protection
```solidity
import {ReentrancyGuard} from "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract OrgResolver is ReentrancyGuard {
    function updateTextRecords(...) external nonReentrant {
        // Implementation
    }
}
```

### Emergency Pause
```solidity
import {Pausable} from "@openzeppelin/contracts/security/Pausable.sol";

contract OrgResolver is Pausable {
    function setText(...) external whenNotPaused {
        // Implementation
    }
}
```

## Deployment Example

```solidity
// Deploy resolver for organization
OrgResolver resolver = new OrgResolver(
    ensRegistry,        // ENS registry address
    organization,       // Organization address
    governanceContract, // DAO voting contract
    gatewayUrl,        // CCIP-Read gateway URL
    gatewaySigner      // Gateway signing key
);

// Set as resolver for domain
ensRegistry.setResolver(namehash("myorg.eth"), address(resolver));
```